name: Validate PR Issue Link

on:
  pull_request_target:
    types: [opened, reopened, edited, synchronize]

jobs:
  validate-issue:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write  
      issues: read

    steps:
      - name: Scan PR description for Issue URL(s)
        id: scan
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          REPO_FULL: ${{ github.repository }}
        run: |
          # Fetch PR body safely (handles null -> empty string)
          BODY=$(gh api repos/$REPO_FULL/pulls/$PR_NUMBER --jq '.body // ""')

          # Look for direct GitHub Issue links (any org/repo)
          URLS=$(printf '%s\n' "$BODY" \
            | grep -Eo 'https://github\.com/julimax/copybara1/issues/[0-9]+' \
            | sort -u)

          if [ -z "$URLS" ]; then
            echo "none=true" >> "$GITHUB_OUTPUT"
          else
            echo "none=false" >> "$GITHUB_OUTPUT"
            {
              echo "list<<EOF"
              echo "$URLS"
              echo "EOF"
            } >> "$GITHUB_OUTPUT"
          fi

      - name: Status — PR has Issue URL(s)
        if: steps.scan.outputs.none == 'false'
        run: |
          echo "✅ PR description contains Issue URL(s):"
          echo "${{ steps.scan.outputs.list }}"

      - name: Status — PR has no Issue URL
        if: steps.scan.outputs.none == 'true'
        run: |
          echo "⚠️ PR description contains no direct Issue URL."

      - name: Comment on PR if missing Issue URL
        if: steps.scan.outputs.none == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          REPO_FULL: ${{ github.repository }}
        run: |
          gh api repos/$REPO_FULL/issues/$PR_NUMBER/comments \
            -f body=$'⚠️ This Pull Request does not include a direct Issue link in its description.\n\nPlease add a URL to a GitHub Issue, for example:\nhttps://github.com/owner/repo/issues/123\n\n(Optional) You can also use keywords like **Closes #123**, but this check only looks for direct links.'


      - name: Update labels based on result
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          REPO_FULL: ${{ github.repository }}
          LABEL_OK: "issue-linked ✅"
          LABEL_MISSING: "needs-issue ❗"
          LABEL_REVIEW: "review me"
        run: |
          set -e

          # URL-encode helper (for DELETE URLs)
          uri() { jq -rn --arg s "$1" '$s|@uri'; }

          ensure_label() {
            local name="$1" color="$2"
            if ! gh api repos/$REPO_FULL/labels --paginate --jq '.[].name' | grep -Fxq "$name"; then
              gh api -X POST "repos/$REPO_FULL/labels" -f name="$name" -f color="$color"
            fi
          }

          # Ensure labels exist in the repository (colors: green, red, blue)
          ensure_label "$LABEL_OK" "2ea043"
          ensure_label "$LABEL_MISSING" "d73a4a"
          ensure_label "$LABEL_REVIEW" "0366d6"

          # Helper to read current labels and test membership
          refresh_labels() {
            CURRENT=$(gh api "repos/$REPO_FULL/issues/$PR_NUMBER/labels" --jq '.[].name')
          }
          has_label() { grep -Fxq "$1" <<< "$CURRENT"; }

          refresh_labels

          if [ "${{ steps.scan.outputs.none }}" = "false" ]; then
            echo "Link found → ensure '$LABEL_OK'; remove '$LABEL_MISSING'. Then add '$LABEL_REVIEW' only if '$LABEL_OK' is present."

            # Ensure OK label present
            if ! has_label "$LABEL_OK"; then
              gh api "repos/$REPO_FULL/issues/$PR_NUMBER/labels" -f labels[]="$LABEL_OK"
            fi

            # Remove MISSING if present
            if has_label "$LABEL_MISSING"; then
              ENC=$(uri "$LABEL_MISSING")
              gh api -X DELETE "repos/$REPO_FULL/issues/$PR_NUMBER/labels/$ENC" || true
            fi

            # Re-check labels AFTER potential changes
            refresh_labels

            # Add REVIEW ONLY if OK is present (and avoid duplicates)
            if has_label "$LABEL_OK" && ! has_label "$LABEL_REVIEW"; then
              gh api "repos/$REPO_FULL/issues/$PR_NUMBER/labels" -f labels[]="$LABEL_REVIEW"
            fi

          else
            echo "No link → add '$LABEL_MISSING'; remove '$LABEL_OK' and '$LABEL_REVIEW' if present."

            if ! has_label "$LABEL_MISSING"; then
              gh api "repos/$REPO_FULL/issues/$PR_NUMBER/labels" -f labels[]="$LABEL_MISSING"
            fi

            if has_label "$LABEL_OK"; then
              ENC=$(uri "$LABEL_OK")
              gh api -X DELETE "repos/$REPO_FULL/issues/$PR_NUMBER/labels/$ENC" || true
            fi

            if has_label "$LABEL_REVIEW"; then
              ENC=$(uri "$LABEL_REVIEW")
              gh api -X DELETE "repos/$REPO_FULL/issues/$PR_NUMBER/labels/$ENC" || true
            fi
          fi

      - name: replace "in review" → "create patch"
        if: github.event.action == 'synchronize'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          REPO_FULL: ${{ github.repository }}
          OLD_LABEL: "in review"
          NEW_LABEL: "create patch"
        run: |
          set -e

          # URL-encode helper for DELETE endpoints
          uri() { jq -rn --arg s "$1" '$s|@uri'; }

          # Ensure NEW_LABEL exists (best-effort)
          if ! gh api "repos/$REPO_FULL/labels" --paginate --jq '.[].name' | grep -Fxq "$NEW_LABEL"; then
            gh api -X POST "repos/$REPO_FULL/labels" -f name="$NEW_LABEL" -f color="6f42c1" || true
          fi

          # Current labels on the PR
          CURRENT=$(gh api "repos/$REPO_FULL/issues/$PR_NUMBER/labels" --jq '.[].name')

          has_label() { grep -Fxq "$1" <<< "$CURRENT"; }

          if has_label "$OLD_LABEL"; then
            echo "Replacing label '$OLD_LABEL' → '$NEW_LABEL' due to synchronize (new commits)."

            # Add NEW_LABEL if not present
            if ! has_label "$NEW_LABEL"; then
              gh api "repos/$REPO_FULL/issues/$PR_NUMBER/labels" -f labels[]="$NEW_LABEL"
            fi

            # Remove OLD_LABEL
            ENC=$(uri "$OLD_LABEL")
            gh api -X DELETE "repos/$REPO_FULL/issues/$PR_NUMBER/labels/$ENC" || true
          else
            echo "Label '$OLD_LABEL' is not present. Nothing to do."
          fi
